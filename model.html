<!-- this file was generated automatically by noweave; better not edit it-->
<html><head><title>Ridesharing Model</title></head><body>
<h1><a name=toc52>Ridesharing Model</a></h1>
<a name="ch-model"><b>[*]</b></a>
<h2><a name=toc53>Ridesharing Setting</a></h2>
<a name="mod-setting"><b>[*]</b></a>
<h3><a name=toc54>Time</a></h3>
<a name="mod-setting: time"><b>[*]</b></a>
<p>
Time is modeled as a positive integer \(1\leq t\leq H\). A time horizon <i>H</i>
bounds the system. Time can be operated on. Times cannot be added, but a later
(greater) time can subtract an earlier (lesser) time. The difference is called
a duration, represented by the symbol \(\delta\). Durations can add and subtract
each other to get new durations, and times can also add and subtract durations
to get new times.
<p>
<h3><a name=toc55>Road Network</a></h3>
<a name="mod-setting: road"><b>[*]</b></a>
<p>
The road network is modeled as a directed graph
\(\mathcal{G}(\mathcal{V},\mathcal{E})\). Vertices in \(\mathcal{V}\) represent
points along roads in the network.  A function \(V:\mathcal{V}\rightarrow \mathbb{R}^2\)
maps vertices to 2-dimensional latitude and longitude
coordinates in the real world, and an inverse function map-matches locations
in the real world to vertices. Edges in \(\mathcal{E}\) represent road segments. The
pair \((a,b)\in \mathcal{V}^2, a\neq b\) exists in \(\mathcal{E}\) only if physical
traffic flows from \(V(a)\) to \(V(b)\), and for all \(c\in\mathcal{V}\setminus\{a,b\}\)
no traffic flows from \(V(a)\) to \(V(c)\) and from
\(V(c)\) to \(V(b)\). A function \(d:\mathcal{E}\rightarrow\mathbb{R}_{>0}\) maps
edges to positive real weights corresponding to distance along the edge, and
the shortest-path distances between the pairs among any three vertices
satisfies the triangle inequality. Figure&nbsp;<a href="#fig:road">[-&gt;]</a> shows an example road
network, drawn in QGIS, that could be supported by Jargo's model.
<p>
<hr>
<img src="res/mod-road.png">
<p>
<b>Portion of a road network graph showing edges (red lines) and vertices
(blue circles) overlayed on top of Manhattan (QGIS 2.18.16, Bing Aerial).
Vertices do not have to be at an intersection (orange circles, lower right).</b>
<a name="fig:road"><b>[*]</b></a>
<hr>
<p>
<h3><a name=toc56>Paths</a></h3>
<a name="mod-setting: paths"><b>[*]</b></a>
<p>
A path \(p=(p_i)_{i\in 1..n}=p_1..p_n\) is defined as a sequence of \(n\)
vertices such that any two adjacent vertices are an edge, or
\((p_i,p_{i+1})\in\mathcal{E}\) for \(i\in 1..(n-1)\). A vertex or edge can
appear multiple times in a path.  The path distance is
$$\sum_{i=1}^{n-1} d(p_i, p_{i+1}).$$
Path \(p\) is a shortest path only if it minimizes the distance out of all
possible paths from \(p_1\) to \(p_n\).  Multiple shortest paths are possible.
<p>
<h3><a name=toc57>Waypoints</a></h3>
<a name="mod-setting: waypoints"><b>[*]</b></a>
<p>
Waypoints are used to describe points in time as well as space.  A waypoint is
defined as a tuple \((\texttt{t},\texttt{v})\), with the domain of \(\texttt{t}\)
as \(1..H\) and the domain of \(\texttt{v}\) as \(\mathcal{V}\). Waypoints can be
labeled in a way that will be discussed later.
<p>
<h3><a name=toc58>Routes</a></h3>
<a name="mod-setting: routes"><b>[*]</b></a>
<p>
Routes are formed by a sequence of waypoints.  A route \(w=(w_i)_{i\in
1..n}=w_1..w_n=(t_1,v_1)..(t_n,v_n)\) is defined as a sequence of \(n\)
waypoints such that \(t_1..t_n\) is strictly increasing and \(v_1..v_n\) is a
path.  In the spatial dimension, function
$$D(w)=\sum_{i=1}^{n-1}d(\pi_\texttt{v}(w_i),\pi_\texttt{v}(w_{i+1}))$$
gives the route distance, analogous to path distance.  In the time dimension,
function
$$\delta(w)=\pi_\texttt{t}(w_n)-\pi_\texttt{t}(w_1)$$
gives the route duration. Given a time \(t\),
$$\begin{align*} w_{\leq
t}=\textrm{sort}(\sigma_{\texttt{t}\leq t}(w))\quad\textrm{and}\quad
w_{>t}=\textrm{sort}(\sigma_{\texttt{t}>t}(w)) \end{align*}$$
give the traveled
route denoted \(w_{\leq t}\), and the remaining route denoted \(w_{>t}\). As the
selection operator imposes no ordering on the resulting set, a
\(\textrm{sort}(...)\) function is introduced to sort a set of waypoints by time
in ascending order, returning a sequence.  For two adjacent waypoints \(w_i\)
and \(w_{i+1}\), function
$$\nu(w_i,w_{i+1})=\frac{d(\pi_\texttt{v}(w_i),\pi_\texttt{v}(w_{i+1}))}
{\pi_\texttt{t}(w_{i+1})-\pi_\texttt{t}(w_i)}$$
gives the waypoint rate, or
more intuitively the speed.  As \(d\) only applies to edges, \(\nu\) only applies
to adjacent waypoints. Speeds can be bounded above by a value
\(\nu^\textrm{max}(v_i,v_{i+1})\) on each edge, for example to describe road
speed limits.
<p>
<h2><a name=toc59>Ridesharing Users</a></h2>
<a name="mod-users"><b>[*]</b></a>
<p>
In Jargo, the basic entity representing a ridesharing participant is the
<em>user</em>.  Table&nbsp;<a href="#tab:mod-users-types">[-&gt;]</a> describes the types of users
recognized by Jargo, and Table&nbsp;<a href="#tab:mod-users-properties">[-&gt;]</a> describes their
properties.  Table&nbsp;<a href="#tab:mod-users-rules">[-&gt;]</a> describes rules governing their
behavior.  A user is classified as a <em>request</em> if it represents a Type&nbsp;1
or Type&nbsp;2 customer, or classified as a <em>server</em> if it represents a Type&nbsp;3
or Type&nbsp;4 vehicle. As only vehicles can move about (P4), only servers are
associated with routes in order to describe the motions. Later, schedules
describing pick-up and drop-off events are defined on the routes.
<p>
<hr>
<table>
<thead><tr><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>Type 1</td><td>Single customer traveling alone</td></tr>
<tr><td>Type 2</td><td>Group of customers traveling together</td></tr>
<tr><td>Type 3</td><td>Ridesharing vehicle with a predefined final destination</td></tr>
<tr><td>Type 4</td><td>Taxi-like vehicle continually serving customers without an explicit destination of its own</td></tr>
</tbody>
</table>
<b>Types of ridesharing users.</b>
<a name="tab:mod-users-types"><b>[*]</b></a>
<p>
<table>
<thead><tr><th>Prop.</th><th>Description</th></tr></thead>
<tr><td>P1</td><td><i>Load.</i> Each user has a non-zero load, indicating a
number of needed seats. For Type 1 users the load is 1, indicating they only
need a single seat. For Type 2 users the load exceeds 1. For Type 3 and Type 4
users the load is negative, indicating they have an availability of seats.</td></tr>
<tr><td>P2</td><td><i>Origin and Destination.</i> Each user has an origin and a
destination, except for Type 4 users that only have an origin.  For Type
1 and Type 2, the origin indicates the initial location of the customer
and the destination indicates the desired final location.  For Type 3, the
origin and destination indicate where the vehicle's ridesharing service begins
and ends</td></tr>
<tr><td>P3</td><td><i>Time Window.</i> Each user has an early time and a
late time, together forming the user's time window. For a Type 1
or Type 2 customer, the time window gives the desired departure time from the
origin and the desired arrival time at the destination.  For a Type 3 or Type 4
vehicle, the time window gives the time when service begins and the latest time
that service can end. The early time precedes the late time</td></tr>
</table>
<b>Ridesharing user properties.</b>
<a name="tab:mod-users-properties"><b>[*]</b></a>
<p>
<table>
<thead><tr><th>Prop.</th><th>Description</th></tr></thead>
<tr><td>P4</td><td><i>Motion.</i> Users are bound to a network of roads, for
example the streets of a city. Only vehicles may directly travel along the
roads, whereas customers must be serviced by a vehicle. Both customers and
vehicles may enter the system at any time and anywhere</td></tr>
<tr><td>P5</td><td><i>Pick-ups and Drop-offs.</i> For a vehicle to service a customer, it
must first travel to the customer's origin to pick up the customer, and then to
the customer's destination to drop off the customer, in that order. The
customer enters the vehicle during the pick-up and exits the vehicle during the
drop-off. These visits must occur within the customer's time window</td></tr>
<tr><td>P6</td><td><i>Vehicle Seats.</i> When a customer enters a vehicle, the customer
occupies a number of seats equal to the customer's load. When it exits the
vehicle, it relinquishes the seats. At no time can the number of occupied seats
exceed the number of available seats in a vehicle</td></tr>
<tr><td>P7</td><td><i>User States.</i> A customer can be in one of three states at any
time: waiting for pick-up; in-transit following a pick-up but
before the drop-off; or arrived at destination. A vehicle can be either
in-service or out-of-service</td></tr>
</table>
<b>Rules governing user behavior.</b>
<a name="tab:mod-users-rules"><b>[*]</b></a>
<hr>
<p>
<h3><a name=toc60>User Relation</a></h3>
<a name="mod-users: user-relation"><b>[*]</b></a>
<p>
A user \(u\) is a 5-tuple defined by
\({u:=(\texttt{q},\texttt{e},\texttt{l},\texttt{o},\texttt{d})}\). The
\(\texttt{q}\) component corresponds to the user load; the
\(\texttt{e}\) and
\(\texttt{l}\) components correspond to the user early and late times; the
\(\texttt{o}\) and
\(\texttt{d}\) components correspond to the user origin and
destination. From P1&ndash;P4, the domain of
\(\texttt{q}\) is the non-zero integers; the domain of
\(\texttt{e}\) is \(1..(H-1)\) and the domain of
\(\texttt{l}\) is \((u_\texttt{e}+1)..H\); the domains of
\(\texttt{o}\) and
\(\texttt{d}\) are both \(\mathcal{V}\).  For a Type 4 vehicle, the destination
can be set to a dummy vertex with edge weight equal to 0 to every other vertex
in the road network.
<p>
The set of all users forms the 5-ary relation \(\mathcal{U}\), called the user
relation.  The set \(\mathcal{U}_\texttt{o}=\pi_\texttt{o}(\mathcal{U})\)
contains all origins and \(\mathcal{U}_\texttt{d}=\pi_\texttt{d}(\mathcal{U})\)
contains all destinations. From P1, a user can be classified as either a
request or a server based on its load.
<p>
As a convenience, the notation \(d_u\) is used to denote the distance of the
shortest path from \(u_\texttt{o}\) to \(u_\texttt{d}\) on graph \(\mathcal{G}\), and
the notation \(\delta_u\) is used to denote the shortest travel duration along
\(d_u\) using the speed limits \(\nu^\textrm{max}\) along the shortest-path edges.
<p>
<h3><a name=toc61>Requests</a></h3>
<a name="mod-users: requests"><b>[*]</b></a>
<p>
A request represents a Type 1 or Type 2 customer.  Relation
\(\mathcal{R}\subseteq\mathcal{U}\),
$$\mathcal{R}=\sigma_{\texttt{q}>0}(\mathcal{U}),$$
forms the set of all requests by taking users with positive loads. The set
\(\mathcal{R}_\texttt{o}=\pi_\texttt{o}(\mathcal{R}\)) is the set of all
request origins and \(\mathcal{R}_\texttt{d}=\pi_\texttt{d}(\mathcal{R})\) is
the set of all request destinations.
<p>
<h3><a name=toc62>Servers</a></h3>
<a name="mod-users: servers"><b>[*]</b></a>
<p>
Likewise, a server represents a Type 3 or Type 4 vehicle.  Relation
\(\mathcal{S}=\mathcal{U}\setminus\mathcal{R}\), or
$$\mathcal{S}=\sigma_{\texttt{q}<0}(\mathcal{U}),$$ forms the set of all
servers. The set \(\mathcal{S}_\texttt{o}=\pi_\texttt{o}(\mathcal{S})\) is the
set of all server origins and
\(\mathcal{S}_\texttt{d}=\pi_\texttt{d}(\mathcal{S})\) is the set of all server
destinations.
<p>
<h3><a name=toc63>Routes</a></h3>
<a name="mod-users: routes"><b>[*]</b></a>
<p>
To encode vehicle motions, Jargo associates each server
\(s\in\mathcal{S}\) with
a route and a schedule. A server's route is a representation of the
corresponding vehicle's motion through the road network while a server's
schedule encodes the times and locations of customer pick-ups and drop-offs.
<p>
Variable \(w\) indicates the route for a server \(s\). As time advances, the
traveled route \(w_{\leq t}\) encodes the server's past motion while the
remaining route \(w_{>t}\) encodes the future motion.  From P2 and P3, Jargo
subjects all routes to two rules:
<ul>
<li>R1.--The time component of the first waypoint equals the server's early
time, and the time component of the last waypoint is not greater than the
server's late time, or \(\pi_\texttt{t}(w_1)=s_\texttt{e}\) and
\(\pi_\texttt{t}(w_{|w|})\leq s_\texttt{l}\);
<li>R2.--The vertex components of the first and last waypoints equal the
server's origin and destination respectively, or
\(\pi_\texttt{v}(w_1)=s_\texttt{o}\) and \(\pi_\texttt{v}(w_{|w|})=s_\texttt{d}\).
</ul>
<p>
<h3><a name=toc64>Schedules</a></h3>
<a name="mod-users: schedules"><b>[*]</b></a>
<p>
A server's schedule describes the events along the route and not any new
motion. It is a subsequence of the server's route \(w\)
$$b=(b_j)_{j\in 1..m}=(w_{i_j})_{j\in 1..m}=(t_{i_1},v_{i_1})..(t_{i_m},v_{i_m}),$$
with \(m\leq |w|\) waypoints. Schedules are subjected to a couple rules. First:
<ul>
<li>R3.--The first and last waypoints \(b_1\) and \(b_m\) equal the first and last
waypoints of \(w\), or \(b_1=w_1\) and \(b_m=w_{|w|}\).
</ul>
This rule will help later when defining departure and arrival times.
Second, from P5:
<ul>
<li>R4.--For each waypoint \(b_j\) for \(j\in 2..(m-1)\), the vertex component is either a
request origin or request destination, or \(\pi_\texttt{v}(b_j)\in
\mathcal{R}_\texttt{o}\cup\mathcal{R}_\texttt{d}\).
</ul>
In other words, each entry or exit must occur at a customer origin or
destination.
<p>
A schedule formalizes the notion of shared travel with other users, as multiple
entries and exits can overlap within the same server route.  At time \(t\), the
traveled schedule denoted \(b_{\leq t}\) encodes the past entries and exits and
is given by \(\sigma_{\texttt{t}\leq t}(b)\). Likewise, the remaining schedule
denoted \(b_{>t}\) encodes the future entries and exits and is given by
\(\sigma_{\texttt{t}>t}(b)\).
<p>
<h3><a name=toc65>Schedule Labels</a></h3>
<a name="mod-users: labels"><b>[*]</b></a>
<p>
Each waypoint in schedule \(b\) has a set of labels in order to identify which
customers are entering and exiting the vehicle at the waypoint's time and
location.  A labeling scheme can be applied to \(b\) to determine each of the
labels. The set of all possible labels depends on the locations of the
waypoints. Let
$$\mathcal{R}'=\sigma_{\texttt{o}\in\pi_\texttt{v}(b)\lor \texttt{d}\in\pi_\texttt{v}(b)}(\mathcal{R})$$
give the set of requests whose origin or destination is found in at least one
waypoint in \(b\). Conceptually, the labeling scheme
$$L:b\rightarrow \mathbb{P}(\mathcal{R}'\cup\{s\})$$
maps elements of \(b\) to elements of the power set of \(\mathcal{R}'\cup\{s\}\).
By using the power set \(P\), a waypoint can have multiple labels,
representing the case where multiple customers enter or exit the vehicle at the
waypoint.  The labeling scheme is subjected to the following labeling rules:
<ul>
<li>R5.--No waypoint can be labeled with \(r\in\mathcal{R}'\) if a schedule for
another server already contains waypoints labeled with \(r\);
<li>R6.--A waypoint \(b_j\in b\) can be labeled with \(r\) only if
\(\pi_\texttt{v}(b_j)=r_\texttt{o}\) or \(\pi_\texttt{v}(b_j)=r_\texttt{d}\);
<li>R7.--If \(b_j\) is to be labeled with \(r\) and
\(\pi_\texttt{v}(b_j)=r_\texttt{o}\), then a second waypoint \(b_{j'}\) such that
\(j'>j\) and \(\pi_\texttt{v}(b_{j'})=r_\texttt{d}\) must also be labeled with \(r\);
<li>R8.--The time components of \(b_j\) and \(b_{j'}\) must be within request
\(r\)'s time window, formally \(r_\texttt{e}\leq \pi_\texttt{t}(b_j)\) and
\(\pi_\texttt{t}(b_{j'})\leq r_\texttt{l}\);
<li>R9.--The number of waypoints labeled with \(r\) must be exactly 0 or 2;
<li>R10.--The first and last waypoints must contain the schedule's server \(\)s
in their labels, and no other waypoint can be labeled with \(s\).
</ul>
Rules R5&ndash;R9 express P5.  Rule R10 can be interpreted to mean that a vehicle
must ``serve itself'' at its own origin and destination.  This last rule helps
to define later concepts.
<p>
<h3><a name=toc66>Server Relation</a></h3>
<a name="user-mod: server-relation"><b>[*]</b></a>
<p>
By combining the routes, schedules, and labels into a set of
\((\texttt{s},\texttt{t},\texttt{v},\texttt{L})\) tuples, a 4-ary relation
\(\mathcal{X}\) can be formed. Jargo calls this relation the server relation.
Each tuple associates the waypoint in the \(\texttt{t}\) and \(\texttt{v}\) components
with the server in the \(\texttt{s}\) component, along with the labels in the
\(\texttt{L}\) component.
<p>
A server's route can be recovered by extracting \(\texttt{t}\) and \(\texttt{v}\)
components and sorting by time, or formally for a given server \(s\), its route
is given by
$$W(\mathcal{X},s)=\textrm{sort}(\pi_{\texttt{t},\texttt{v}}(\sigma_{\texttt{s}=s}(\mathcal{X}))).$$
Similarly, a server's schedule can be recovered by extracting only those
waypoints that are labeled, formally
$$B(\mathcal{X},s)=\textrm{sort}(\pi_{\texttt{t},\texttt{v}}(\sigma_{\texttt{s}=s\land |\texttt{L}|>0}(\mathcal{X}))).$$

The server relation can be used to define the remaining physical concepts, P6 and P7.
<p>
<h3><a name=toc67>Request Status</a></h3>
Given a request \(r\), the function

<a name="eq:status"><b>[*]</b></a>
$$\textrm{status}(\mathcal{X},r,t)=|\sigma_{\texttt{t}\leq t\land
r\in\texttt{L}}(\mathcal{X})|$$

gives the count of the tuples labeled with \(r\) before or on a given time. From
the labeling rules, the count can be only 0, 1, or 2. These counts correspond
to request waiting, in-transit, and arrived states from P7, respectively.
<p>
Given a server \(s\), knowing the in-transit requests for \(s\) can be useful for
pricing and other rider-related
metrics.
These requests can be found by
$$\mathcal{Q}(\mathcal{X},s,t)=\{r\in\mathcal{R}\mid\textrm{status}(\mathcal{X},r,t)=1
\land\pi_\texttt{s}(\sigma_{r\in\texttt{L}}(\mathcal{X}))=s\}.$$

<h3><a name=toc68>Load Burden</a></h3>
The load burden on \(s\) can be computed using the in-transit requests by

<a name="eq:load"><b><a name="NWD2Iyr5A-7">[*]</a></b></a>
$$Q(\mathcal{X},s,t)=\sum_{r\in\mathcal{Q}(\mathcal{X},s,t)}r_\texttt{q}.$$

From P6, server routes are subject to the additional rule:
<ul>
<li>R11.--\(Q(\mathcal{X},s,t)\leq -s_\texttt{q}\) must be true for all \(s\) and \(t\).
</ul>
<p>
<h2><a name=toc69>Ridesharing Metrics</a></h2>
<a name="mod-metrics"><b>[*]</b></a>
<p>
A variety of metrics can be measured by simple operations on \(\mathcal{U}\) and
\(\mathcal{X}\). This section lists those that have been implemented in Jargo.
<p>
<h3><a name=toc70>Assignments</a></h3>
<a name="mod-metrics: assignments"><b>[*]</b></a>
<p>
Server \(s\) is said to be assigned to request \(r\) at time \(t\) only if
\(\textrm{status}(\mathcal{X},r,t)=2\). That is, the request's status is arrived
at time \(t\). The set of \((s,r)\) pairs where this property is true is called
the set of assignments, formally

<a name="eq:assignments"><b>[*]</b></a>
$$\textit{assignments }A(\mathcal{X},t)=
\{(s,r)\in\mathcal{S}\times \mathcal{R} \mid \textrm{status}(\mathcal{X},r,t)=2\}.$$

Using the assignments,

<a name="eq:assigned-requests"><b>[*]</b></a>
$$\begin{align}
\textit{assigned requests }R^\textrm{ok}(\mathcal{X},t)&=\pi_\texttt{r}(A(\mathcal{X},t))\textrm{, and}\\
\textit{unassigned requests }R^\textrm{ko}(\mathcal{X},t)&=\mathcal{R}\setminus\mathcal{R}^\textrm{ok}(\mathcal{X},t).
\end{align}$$

The server assigned to \(r\) can be obtained with

$$S(\mathcal{X},r,t)=\{s\in\mathcal{S}\mid\textrm{status}(\mathcal{X},r,t)=2\},$$

guaranteed to return only one server due to R5.
Likewise, the set of requests assigned to \(s\) can be obtained with

<a name="eq:R(X,s,t)"><b>[*]</b></a>
$$R(\mathcal{X},s,t)=\{r\in\mathcal{R}\mid\textrm{status}(\mathcal{X},r,t)=2\}.$$

<p>
<h3><a name=toc71>Service Rate</a></h3>
<a name="mod-metrics: service-rate"><b>[*]</b></a>
The service rate is the number of assigned requests over the number of all requests, or

<a name="eq:service-rate"><b>[*]</b></a>
$$\textit{service rate }\mu(\mathcal{X},t)=\frac{|R^\textrm{ok}(\mathcal{X},t)|}{|\mathcal{R}|}.$$

<p>
<h3><a name=toc72>Distances</a></h3>
<a name="mod-metrics: distances"><b>[*]</b></a>
<p>
The base distance is the sum of the shortest-path distances for all users, or

<a name="eq:base-distance"><b>[*]</b></a>
$$\textit{base distance }D^\textrm{base}(\mathcal{U})=\sum_{u\in U}d_u.$$

The travel distance for one server \(s\) is the distance of its route,
\(D(W(\mathcal{X},s))\), and the travel duration can be found with
\(\delta(W(\mathcal{X},s))\).
<p>
For a server with route \(w\), travel distance \(D(w)\) can be partitioned into
cruising distance \(D_0(w)\) and
service distance \(D_1(w)\).
The cruising distance sums the distance along portions where the load burden is zero.
The service distance sums the distance along portions of \(w\) where the
load burden is non-zero.
Formally, partition \(w\) into a set of substrings \(\Omega(w)\) such that each waypoint
in \(w\) is a member of exactly one substring and that for all substrings \(\omega\in \Omega\),

$$\textrm{either }Q(\mathcal{X},s,t)=0\textrm{ is true for all }t\in \pi_\texttt{t}(\omega),\label{eq:slack}\tag{1}$$

$$\textrm{or }Q(\mathcal{X},s,t)>0\textrm{ is true for all }t\in \pi_\texttt{t}(\omega).\label{eq:block}\tag{2}$$

The equations can be used to partition \(\Omega(w)\) into two subsets,

$$\begin{align*}
\Omega_0(w)&=\{\omega\in \Omega(w)\mid \omega\textrm{ satisfies Eq.~\ref{eq:slack}}\}\textrm{ and }\\
\Omega_1(w)&=\{\omega\in \Omega(w)\mid \omega\textrm{ satisfies Eq.~\ref{eq:block}}\}.
\end{align*}$$

The distances of each of the substrings in each subset can be summed
to get
$$D_0(w)=\sum_{\omega\in \Omega_0(w)} D(\omega)\quad\textrm{and}\quad
  D_1(w)=\sum_{\omega\in \Omega_1(w)} D(\omega).$$
These distances are written as

<a name="eq:cruising-distance"><b>[*]</b></a>
$$\begin{align}
\textit{cruising distance }D^\textrm{cruise} (\mathcal{X},s)&=D_0(W(\mathcal{X},s)),\textrm{ and}\\
\textit{service distance } D^\textrm{service}(\mathcal{X},s)&=D_1(W(\mathcal{X},s)).
\end{align}$$

<p>
<h3><a name=toc73>Detours and Delays</a></h3>
<a name="mod-metrics: delays"><b>[*]</b></a>
<p>
In physical terms, the detour route for a customer is the portion of a vehicle's
route between when it visits the customer's origin and destination. Formally, let
\(w=W(\mathcal{X},S(\mathcal{X},r,H))\) be the route of the server assigned to \(r\).
The detour route \(\Delta W(\mathcal{X},r)\) is an \(m\)-length substring of \(w\) given by
\(\Delta W(\mathcal{X},r)=w_{1+k}..w_{m+k}\) such that for some \(k\),
<ul>
<li>\(\Delta W(\mathcal{X},r)\) begins at \(r_\texttt{o}\), or \(\pi_\texttt{v}(w_{1+k})=r_\texttt{o}\),
<li>\(\Delta W(\mathcal{X},r)\) ends at \(r_\texttt{d}\), or \(\pi_\texttt{v}(w_{m+k})=r_\texttt{d}\), and
<li>the first and last waypoints of \(\Delta W(\mathcal{X},r)\) are labeled with \(r\), or \(r\in\pi_\texttt{L}(w_{1+k})\cap\pi_\texttt{L}(w_{m+k})\).
</ul>
Observe that due to the labeling rules, only one value of \(k\) can satisfy these
conditions. The first and last waypoints \(w_{1+k}\) and \(w_{m+k}\) can be found by
the equations on users,

<a name="eq:pickup"><b>[*]</b></a>
$$\begin{align}
\textrm{pickup}(\mathcal{X},u)&=\pi_{\texttt{t},\texttt{v}}(\sigma_{\texttt{v}=u_\texttt{o}\land u\in\texttt{L}}(\mathcal{X}))\textrm{, and}\\
\textrm{dropoff}(\mathcal{X},u)&=\pi_{\texttt{t},\texttt{v}}(\sigma_{\texttt{v}=u_\texttt{d}\land u\in\texttt{L}}(\mathcal{X})),
\end{align}$$

by substituting \(r\) for \(u\).
Note that if a server is substituted for \(u\), these equations give the start and
end waypoints of the server's route due to R3 and R10.
These two equations can also be used to give two times for
any user,

<a name="eq:departure-time"><b>[*]</b></a>
$$\begin{align}
\textit{departure time }t^\textrm{depart}(\mathcal{X},u)&=\pi_\texttt{t}(\textrm{pickup}(\mathcal{X},u))\textrm{, and}\\
\textit{arrival time }t^\textrm{arrive}(\mathcal{X},u)&=\pi_\texttt{t}(\textrm{dropoff}(\mathcal{X},u)).
\end{align}$$

In the real world, the time until a vehicle picks up a customer can be of interest.
This pick-up delay can be found with

<a name="eq:pick-up delay"><b>[*]</b></a>
$$\textit{pick-up delay }\delta^\textrm{pickup}(\mathcal{X},r)=\pi_\texttt{t}(\textrm{pickup}(\mathcal{X},r))-r_\texttt{e}.$$

<p>
The detour route \(\Delta W(\mathcal{X},r)\) can only apply to assigned requests. If
a detour route exists, then
the transit distance and duration are

<a name="eq:transit-distance"><b>[*]</b></a>
$$\begin{align}
\textit{transit distance }D^\textrm{transit}(\mathcal{X},r)&=D(\Delta W(\mathcal{X},r))\textrm{, and}\\
\textit{transit duration }\delta^\textrm{transit}(\mathcal{X},r)&=\delta(\Delta W(\mathcal{X},r)).
\end{align}$$

Similarly, the detour distance and duration are

<a name="eq:detour-distance"><b>[*]</b></a>
$$\begin{align}
\textit{detour distance }D^\textrm{detour}(\mathcal{X},r)&=D^\textrm{transit}(\mathcal{X},r)-d_r\textrm{, and}\\
\textit{detour duration }\delta^\textrm{detour}(\mathcal{X},r)&=\delta^\textrm{transit}(\mathcal{X},r)-\delta_r.
\end{align}$$

Finally, the travel duration is the sum of the pick-up and transit durations,

<a name="eq:travel-duration"><b>[*]</b></a>
$$\textit{travel duration }\delta^\textrm{travel}(\mathcal{X},r)=\delta^\textrm{pickup}(\mathcal{X},r)+\delta^\textrm{transit}(\mathcal{X},r)
=\pi_\texttt{t}(\textrm{dropoff}(\mathcal{X},r))-r_\texttt{e}.$$

<p>
<h3><a name=toc74>Utilization</a></h3>
<a name="mod-metrics: utilization"><b>[*]</b></a>
<p>
The percentage of servers that are assigned to at least one request is given by

<a name="eq:server-utilization"><b>[*]</b></a>
$$\textit{server utilization }\rho^\textrm{server}(\mathcal{X})=\frac{|\pi_\texttt{s}(\mathcal{A}(\mathcal{X}))|}{|\mathcal{S}|}.$$

<a name="NWD2RoA1x-8">The distance utilization is</a>

<a name="eq:distance-utilization"><b>[*]</b></a>
$$\textit{distance utilization }\rho^\textrm{distance}(\mathcal{X})=
\frac{\sum_{s\in\mathcal{S}}D^\textrm{service}(\mathcal{X},s)}
{\sum_{s\in\mathcal{S}}D(\mathcal{X},s)}.$$

<p>
<h2><a name=toc75>SQL Schema</a></h2>
<a name="mod-schema"><b>[*]</b></a>
<p>
The simple constraints allowed by the SQL standard <b>[</b>ISO/IEC 9075<b>]</b> 
(<tt>CHECK</tt>, <tt>UNIQUE</tt>, <tt>NOT NULL</tt>, <tt>FOREIGN KEY</tt>) are
unable to express the complex ridesharing properties and rules, and
consequently a direct ``translation'' of the ridesharing relations into SQL is
not possible without either making code extensions to SQL or reorganizing the
relational ridesharing model.
<p>
Jargo implements the following schema entirely in standard SQL without any code
extensions while staying faithful to the model. In this schema, <i>tables</i>
capture the descriptive elements of the model and <i>views</i> express the
analytical measures. Tables are further organized into property, solution, and
constraint tables. Property tables store the road network \(\mathcal{G}\) and the
user relation \(\mathcal{U}\).  Solution tables store the server relation
\(\mathcal{X}\).  Constraint tables store copies of data from other tables for
validation purposes.  The views are mostly defined on the constraint tables.
<p>
Diagrams of the SQL tables are included in this chapter. In the diagrams,
primary keys are indicated in italics. Elsewhere, column names are
distinguished by sans serif script.  Parentheses are used to logically
group together columns.  A parent table next to a group of columns indicates
foreign key. In SQL, foreign keys must reference their values from the primary
key of the parent table. Many of the table diagrams contain duplicate columns
(for example, sid shows up three times in Table W).  These duplicates
are included for illustrating the foreign key relationships, but in practice
the duplicates are implemented as single columns participating in multiple
foreign keys.
<p>
This section also includes Java code chunks. Double-angle brackets enclose the
chunk name, used to refer to the chunk in other parts of the document.
Anything after the equals sign and before the ``at'' sign is live code. Noweb
is used to compile the code chunks into correct Java source code.
<p>
<h3><a name=toc76>Road Network Tables (Tables V and E)</a></h3>
<a name="mod-schema: road"><b>[*]</b></a>
<p>
Each vertex \(v\in\mathcal{V}\) is stored in Table V along with its coordinates
\(V(v)\) while each edge \((a,b)\in\mathcal{E}\) is stored in Table E along with
its weight \(d(a,b)\) and speed limit \(\nu^\textrm{max}(a,b)\).  Table V thus has
three columns, storing \(v\) in primary key column \(\textsf{v}\) (\(\texttt{P1}\)) and its
coordinates in column \(\textsf{lng}\) and \(\textsf{lat}\).  Likewise, Table E has
four columns, storing \(a\) and \(b\) in column \(\textsf{v1}\) and \(\textsf{v2}\),
\(d(a,b)\) in column \(\textsf{dd}\), and \(\nu^\textrm{max}(a,b)\) in column
\(\textsf{nu}\).  The four columns together form the primary key (\(\texttt{P2}\)) in order
to be referenced by later tables.  Foreign keys on \(\textsf{v1}\) (\(\texttt{F1}\)) and
\(\textsf{v2}\) (\(\texttt{F2}\)) referencing Table V validate that \(a\) and \(b\) are actual
vertices.
<hr>
<table border><!-- alignment is |c|l|--><!-- 2 columns--><tr><td align="center">
Table V (Vertices)</td></tr>
<tr><td align="center">
Column </td><td align="left" valign="top">Description</td></tr>
<tr><td align="center"><i>v</i> </td><td align="left" valign="top">Vertex \(v\in\mathcal{V}\) </td></tr>
<tr><td align="center">lng </td><td align="left" valign="middle" rowspan=2>Vertex coordinate <i>V(v)</i></td></tr>
<tr><td align="center">lat </td></tr>
</table>
<p>
<table border><!-- alignment is |c|c|l|--><!-- 3 columns--><tr><td align="center">
Table E (Edges)</td></tr>
<tr><td align="center">
Column </td><td align="center">Parent </td><td align="left" valign="top">Description</td></tr>
<tr><td align="center"><i>v1</i> </td><td align="center">Table V </td><td align="left" valign="middle" rowspan=2>Edge \((a, b)\in\mathcal{E}\)</td></tr>
<tr><td align="center"><i>v2</i> </td><td align="center">Table V </td></tr>
<tr><td align="center"><i>dd</i> </td><td align="center"></td><td align="left" valign="middle">Weight \(d(a,b)\)</td></tr>
<tr><td align="center"><i>nu</i> </td><td align="center"></td><td align="left" valign="middle">Max. speed \(\nu^\textrm{max}(a,b)\)</td></tr>
</table>
<hr>
<p>
<a name="NWD1ryIo2-9">Jargo considers vertex 0 to be a dummy vertex where any edged formed by 0 has</a>
no weight. To implement the dummy vertex, constraint (<code>C11</code>) is added that
states \(\textsf{dd}\) must be 0 if either \(\textsf{v1}\) or \(\textsf{v2}\) is 0.
<p>
Here are the SQL statements to construct the tables.
<p>
<pre><a name="NW1ryIo2-RzwV3-1" href="#NWD1ryIo2-9"><dfn>&lt;Create Table V statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE V (&quot;
  + &quot;v   int  CONSTRAINT P1 PRIMARY KEY,&quot;
  + &quot;lng int  CONSTRAINT C1 NOT NULL,&quot;
  + &quot;lat int  CONSTRAINT C2 NOT NULL,&quot;
  + &quot;CONSTRAINT C3 CHECK (lng BETWEEN -1800000000 AND 1800000000),&quot;
  + &quot;CONSTRAINT C4 CHECK (lat BETWEEN  -900000000 AND  900000000)&quot;
  + &quot;)&quot;
</pre><p>

<pre><a name="NW1ryIo2-2WHSWQ-1" href="#NW1ryIo2-2WHSWQ-1"><dfn>&lt;Create Table E statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE E (&quot;
  + &quot;v1  int  CONSTRAINT C5 NOT NULL,&quot;
  + &quot;v2  int  CONSTRAINT C6 NOT NULL,&quot;
  + &quot;dd  int  CONSTRAINT C7 NOT NULL,&quot;
  + &quot;nu  int  CONSTRAINT C8 NOT NULL,&quot;
  + &quot;CONSTRAINT F1 FOREIGN KEY (v1) REFERENCES V (v),&quot;
  + &quot;CONSTRAINT F2 FOREIGN KEY (v2) REFERENCES V (v),&quot;
  + &quot;CONSTRAINT P2 PRIMARY KEY (v1, v2, dd, nu),&quot;
  + &quot;CONSTRAINT C9 CHECK (nu &gt;= 0),&quot;
  + &quot;CONSTRAINT C10 CHECK (v1 &lt;&gt; v2),&quot;
  + &quot;CONSTRAINT C11 CHECK (&quot;
  + &quot;  CASE WHEN v1 = 0 OR v2 = 0&quot;
  + &quot;    THEN dd = 0&quot;
  + &quot;    ELSE dd &gt; 0&quot;
  + &quot;  END&quot;
  + &quot;)&quot;
  + &quot;)&quot;
</pre><p>

<h3><a name=toc77>User Tables (Table UQ, UE, UL, UO, UD, and UB)</a></h3>
<a name="mod-schema: user"><b>[*]</b></a>
<p>
To allow other tables to reference specific user components, the user relation
is partitioned into five 2-column tables, UQ, UE, UL, UO, and UD, by taking
projections on the respective \(\texttt{q}\), \(\texttt{e}\), \(\texttt{l}\), \(\texttt{o}\),
and \(\texttt{d}\) components. Each row is a key-value pair, storing a unique
\(\textsf{uid}\) for user identification as the key alongside the component value,
and each row is also its own primary key.  A sixth table UB is introduced to
store base costs for computing \(D^\textrm{base}\) and \(\rho^\textrm{distance}\).
Table UO and UD can be referenced to Table V to validate against property P2
and rule P4.
<hr>
<table border><!-- alignment is |c|c|l|--><!-- 3 columns--><tr><td align="center">
User Tables</td></tr>
<tr><td align="center">
Table </td><td align="center">Columns </td><td align="left" valign="top">Description </td></tr>
<tr><td align="center"><a name="NWD1ryIo2-A">UQ </a></td><td align="center"><i>uid</i>, <i>val</i> </td><td align="left" valign="top">User load \(u_q\) </td></tr>
<tr><td align="center">UE </td><td align="center"><i>uid</i>, <i>val</i> </td><td align="left" valign="top">User early time \(u_e\) </td></tr>
<tr><td align="center">UL </td><td align="center"><i>uid</i>, <i>val</i> </td><td align="left" valign="top">User late time \(u_l\) </td></tr>
<tr><td align="center">UO </td><td align="center"><i>uid</i>, <i>val</i> </td><td align="left" valign="top">User origin \(u_o\) </td></tr>
<tr><td align="center">UD </td><td align="center"><i>uid</i>, <i>val</i> </td><td align="left" valign="top">User destination \(u_d\) </td></tr>
<tr><td align="center">UB </td><td align="center"><i>uid</i>, <i>val</i> </td><td align="left" valign="top">User base cost \(d_u\) </td></tr>
</table>
<hr>
<p>
<pre><a name="NW1ryIo2-llmAG-1" href="#NWD1ryIo2-A"><dfn>&lt;Create Table UQ statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE UQ (&quot;
  + &quot;uid int  CONSTRAINT C12 NOT NULL,&quot;
  + &quot;uq  int  CONSTRAINT C13 NOT NULL,&quot;
  + &quot;CONSTRAINT C14 UNIQUE (uid),&quot;
  + &quot;CONSTRAINT C15 CHECK (uq != 0),&quot;
  + &quot;CONSTRAINT P3 PRIMARY KEY (uid, uq)&quot;
  + &quot;)&quot;
</pre><p>

<pre><a name="NW1ryIo2-sBCgz-1" href="#NW1ryIo2-sBCgz-1"><dfn>&lt;Create Table UE statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE UE (&quot;
  + &quot;uid int  CONSTRAINT C16 NOT NULL,&quot;
  + &quot;ue  int  CONSTRAINT C17 NOT NULL,&quot;
  + &quot;CONSTRAINT C18 CHECK (ue BETWEEN 0 AND 86400000),&quot;
  + &quot;CONSTRAINT C19 UNIQUE (uid),&quot;
  + &quot;CONSTRAINT P4 PRIMARY KEY (uid, ue)&quot;
  + &quot;)&quot;
</pre><p>

<pre><a name="NW1ryIo2-3Q8NSk-1" href="#NW1ryIo2-3Q8NSk-1"><dfn>&lt;Create Table UL statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE UL (&quot;
  + &quot;uid int  CONSTRAINT C20 NOT NULL,&quot;
  + &quot;ul  int  CONSTRAINT C21 NOT NULL,&quot;
  + &quot;CONSTRAINT C22 UNIQUE (uid),&quot;
  + &quot;CONSTRAINT C23 CHECK (ul BETWEEN 0 AND 86400000),&quot;
  + &quot;CONSTRAINT P5 PRIMARY KEY (uid, ul)&quot;
  + &quot;)&quot;
</pre><p>

<pre><a name="NW1ryIo2-qCW00-1" href="#NW1ryIo2-qCW00-1"><dfn>&lt;Create Table UO statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE UO (&quot;
  + &quot;uid int  CONSTRAINT C24 NOT NULL,&quot;
  + &quot;uo  int  CONSTRAINT C25 NOT NULL,&quot;
  + &quot;CONSTRAINT F3 FOREIGN KEY (uo) REFERENCES V (v),&quot;
  + &quot;CONSTRAINT C26 UNIQUE (uid),&quot;
  + &quot;CONSTRAINT P6 PRIMARY KEY (uid, uo)&quot;
  + &quot;)&quot;
</pre><p>

<pre><a name="NW1ryIo2-1OVMyH-1" href="#NW1ryIo2-1OVMyH-1"><dfn>&lt;Create Table UD statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE UD (&quot;
  + &quot;uid int  CONSTRAINT C27 NOT NULL,&quot;
  + &quot;ud  int  CONSTRAINT C28 NOT NULL,&quot;
  + &quot;CONSTRAINT F4 FOREIGN KEY (ud) REFERENCES V (v),&quot;
  + &quot;CONSTRAINT C29 UNIQUE (uid),&quot;
  + &quot;CONSTRAINT P7 PRIMARY KEY (uid, ud)&quot;
  + &quot;)&quot;
</pre><p>
<pre><a name="NW1ryIo2-3QSM5L-1" href="#NW1ryIo2-3QSM5L-1"><dfn>&lt;Create Table UB statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE UB (&quot;
  + &quot;uid int  CONSTRAINT C30 NOT NULL,&quot;
  + &quot;ub  int  CONSTRAINT C31 NOT NULL,&quot;
  + &quot;CONSTRAINT C32 CHECK (ub &gt;= 0),&quot;
  + &quot;CONSTRAINT C33 UNIQUE (uid),&quot;
  + &quot;CONSTRAINT P8 PRIMARY KEY (uid, ub)&quot;
  + &quot;)&quot;
</pre><p>

<h3><a name=toc78>Routes Table (Table W)</a></h3>
<a name="mod-schema: routes"><b>[*]</b></a>
<p>
Table W has eight columns, \(\textsf{sid}\), \(\textsf{se}\), \(\textsf{t1}\), \(\textsf{v1}\),
\(\textsf{t2}\), \(\textsf{v2}\), \(\textsf{dd}\), and \(\textsf{nu}\).  The \(\texttt{s}\),
\(\texttt{t}\), and \(\texttt{v}\) components of \(\mathcal{X}\) are stored in the
(\(\textsf{sid}\), \(\textsf{t2}\), \(\textsf{v2}\)) columns.  By definition, the sequence
of vertices in a route must form a path and the speed of adjacent waypoints
cannot exceed the limit \(\nu^\textrm{max}\).  To enforce these rules, the
predecessor waypoint is stored in the (\(\textsf{sid}\), \(\textsf{t1}\),
\(\textsf{v1}\)) columns.  The (\(\textsf{v1}\), \(\textsf{v2}\)) columns can thus identify
an edge. Columns \(\textsf{dd}\) and \(\textsf{nu}\) are added to store the weight and
speed limit on the edge, and (\(\textsf{v1}\), \(\textsf{v2}\), \(\textsf{dd}\),
\(\textsf{nu}\)) is referenced by foreign key to Table E (<code>F19</code>) to validate the
values. A row-level \(\texttt{CHECK}\) constraint (<code>C56</code>) validates that the
speed \(\textsf{dd}/(\textsf{t2}-\textsf{t1})\) is not greater than the maximum
free-flow speed, \(\textsf{nu}\).
<hr>
<table border><!-- alignment is |c|c|l|--><!-- 3 columns--><tr><td align="center">
Table W (Routes) </td></tr>
<tr><td align="center">
Col. </td><td align="center">Parent </td><td align="left" valign="top">Description </td></tr>
<tr><td align="center"><i>sid</i> </td><td align="center">Table S </td><td align="left" valign="top">Identification for server \(s\in\mathcal{S}\) </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=2 valign="middle">Table UE </td><td align="left" rowspan=2 valign="middle">Server early time \(s_\texttt{e}\) </td></tr>
<tr><td align="center">se </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=3 valign="middle">Table W </td><td align="left" rowspan=3 valign="middle">Predecessor waypoint \(w_{i-1}\) </td></tr>
<tr><td align="center">t1 </td></tr>
<tr><td align="center">v1 </td></tr>
<tr><td align="center"><i>t2</i> </td><td align="center"></td><td align="left" valign="middle" rowspan=2>Waypoint \(w_i\) </td></tr>
<tr><td align="center"><i>v2</i> </td><td align="center"></td></tr>
<tr><td align="center">v1 </td><td align="center" rowspan=4 valign="middle">Table E </td><td align="left" rowspan=4 valign="middle">Properties of edge \(\pi_\texttt{v}(w_{i-1}),\pi_\texttt{v}(w_i)\)</td></tr>
<tr><td align="center">v2 </td></tr>
<tr><td align="center">dd </td></tr>
<tr><td align="center">nu </td></tr>
</table>
<hr>
<p>
The below items are easily implemented in SQL and establish that each
(sid, t1, v1) is indeed the predecessor to
(sid, t2, v2) in the same row (refer to the SQL
statements below):
<ol>
<li>The predecessor (sid, t1, v1) must reference
an existing waypoint (sid, t2, v2) from the table
(<code>F20</code>);
<li>Out of all rows, (sid, t1) must be unique and
(sid, t2) must be unique (<code>C54</code>, <code>C55</code>);
<li>Column t2 and v2 cannot be null (<code>C52</code>, <code>C53</code>);
<li>Unless t2 is equal to the server's early time, t1
cannot be null and it must be less than t2, otherwise t1,
v1, dd, and nu must all be null (<code>C56</code>).
</ol>
<a name="NWD1ryIo2-B">The (sid, t2, v2) columns are the primary key</a>
(<code>P11</code>) in order to allow the self-referencing foreign key in the first item.
The last item handles the case where the first waypoint in a server's route has
no predecessor. Only in this case are t1, v1, dd,
and nu are allowed to be null.  From rule R1, the first waypoint is
detected by checking if t2 is equal to the server's early time, stored
in column se. The (sid, se) columns are referenced
to UE to validate the early time (<code>F18</code>).
<p>
<pre><a name="NW1ryIo2-2FnbXJ-1" href="#NWD1ryIo2-B"><dfn>&lt;Create Table W statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE W (&quot;
  + &quot;sid int  CONSTRAINT C50 NOT NULL,&quot;
  + &quot;se  int  CONSTRAINT C51 NOT NULL,&quot;
  + &quot;t1  int  ,&quot;
  + &quot;v1  int  ,&quot;
  + &quot;t2  int  CONSTRAINT C52 NOT NULL,&quot;
  + &quot;v2  int  CONSTRAINT C53 NOT NULL,&quot;
  + &quot;dd  int ,&quot;
  + &quot;nu  int ,&quot;
  + &quot;CONSTRAINT P11 PRIMARY KEY (sid, t2, v2),&quot;
  + &quot;CONSTRAINT F17 FOREIGN KEY (sid) REFERENCES S,&quot;
  + &quot;CONSTRAINT F18 FOREIGN KEY (sid, se) REFERENCES UE (uid, ue),&quot;
  + &quot;CONSTRAINT F19 FOREIGN KEY (v1, v2, dd, nu) REFERENCES E,&quot;
  + &quot;CONSTRAINT F20 FOREIGN KEY (sid, t1, v1) REFERENCES W (sid, t2, v2) INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT C54 UNIQUE (sid, t1),&quot;
  + &quot;CONSTRAINT C55 UNIQUE (sid, t2),&quot;
  + &quot;CONSTRAINT C56 CHECK (&quot;
  + &quot;  CASE WHEN t1 IS NULL&quot;
  + &quot;    THEN t2 = se AND v1 IS NULL AND dd IS NULL AND nu IS NULL&quot;
  + &quot;    ELSE dd/(t2-t1) &lt;= nu AND t1 &lt; t2&quot;
  + &quot;  END&quot;
  + &quot;)&quot;
  + &quot;)&quot;
</pre><p>

<h3><a name=toc79>Labels Table (Table PD)</a></h3>
<a name="mod-schema: labels"><b>[*]</b></a>
<p>
Table PD (for ``pick-ups and drop-offs'') contains four columns, sid,
t2, v2, and rid.  The (sid, t2,
v2) columns reference Table W (<code>F23</code>), and the rid column
indicates the label on that waypoint.  Each row is its own primary key
(<code>P12</code>) in order to be referenced by the CPD constraint table.  A waypoint
can have multiple labels simply by listing the waypoint multiple times with
different values of rid.
<hr>
<table border><!-- alignment is |c|c|l|--><!-- 3 columns--><tr><td align="center">
Table PD (Pick-up and Drop-off Labels)</td></tr>
<tr><td align="center"><a name="NWD1ryIo2-C"></a>
Col. </td><td align="center">Parent </td><td align="left" valign="top">Description </td></tr>
<tr><td align="center"><i>sid</i> </td><td align="center" valign="middle" rowspan=3>Table W </td><td align="left" valign="middle" rowspan=3>Waypoint \(w_i\) (schedule element \(b_j\)) </td></tr>
<tr><td align="center"><i>t2</i> </td></tr>
<tr><td align="center"><i>v2</i> </td></tr>
<tr><td align="center"><i>rid</i> </td><td align="center">Table R </td><td align="left" valign="top">Identification for request \(r\in\mathcal{R}\) </td></tr>
</table>
<hr>
<p>
<pre><a name="NW1ryIo2-1aGcZB-1" href="#NWD1ryIo2-C"><dfn>&lt;Create Table PD statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE PD (&quot;
  + &quot;sid int  CONSTRAINT C57 NOT NULL,&quot;
  + &quot;t2  int  CONSTRAINT C58 NOT NULL,&quot;
  + &quot;v2  int  CONSTRAINT C59 NOT NULL,&quot;
  + &quot;rid int  CONSTRAINT C60 NOT NULL,&quot;
  + &quot;CONSTRAINT P12 PRIMARY KEY (sid, t2, v2, rid),&quot;
  + &quot;CONSTRAINT F21 FOREIGN KEY (sid) REFERENCES S,&quot;
  + &quot;CONSTRAINT F22 FOREIGN KEY (rid) REFERENCES R,&quot;
  + &quot;CONSTRAINT F23 FOREIGN KEY (sid, t2, v2) REFERENCES W INITIALLY DEFERRED&quot;
  + &quot;)&quot;
</pre><p>

<h3><a name=toc80>User Constraint Tables (Tables S and R)</a></h3>
<a name="mod-schema: user-constraint"><b>[*]</b></a>
<p>
Table S and Table R enforce the remaining user constraints.  Both tables have
six columns, one for each of uq, ue, ul,
uo, ud, and ub, to store user data. A seventh column
stores the user identifier as the primary key. The identifier is stored in the
sid column for Table S and the rid column for Table R.  Each
(sid, column) or (rid, column) pair references the
corresponding user property table, for example (sid, uq)
references Table UQ.
<p>
Properties P1 and P3 that could not be enforced in the user tables are now
enforced through simple constraints on S and R.  A <tt>CHECK</tt> constraint
validates that uq is less than 0 in Table S (<code>C40</code>), and another
<tt>CHECK</tt> constraint validates it is greater than 0 in Table R (<code>C48</code>),
corresponding to servers and requests (property P1). Likewise, a <tt>CHECK</tt>
constraint validates that ue is less than ul (<code>C41</code>,
<code>C49</code>) (property P3). None of the columns can be null to prevent incomplete
users.
<hr>
<table border><!-- alignment is |c|l|--><!-- 2 columns--><tr><td align="center"><a name="NWD1ryIo2-D"></a>
User Constraint Tables</td></tr>
<tr><td align="center">
Table </td><td align="left" valign="top">Columns </td></tr>
<tr><td align="center">Table S </td><td align="left" valign="top"><i>sid</i>, sq, se, sl, so, sd, sb </td></tr>
<tr><td align="center">Table R </td><td align="left" valign="top"><i>rid</i>, rq, re, rl, ro, rd, rb </td></tr>
</table>
<hr>
<p>
<pre><a name="NW1ryIo2-2D0DN7-1" href="#NWD1ryIo2-D"><dfn>&lt;Create Table S statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE S (&quot;
  + &quot;sid int  CONSTRAINT P9 PRIMARY KEY,&quot;
  + &quot;sq  int  CONSTRAINT C34 NOT NULL,&quot;
  + &quot;se  int  CONSTRAINT C35 NOT NULL,&quot;
  + &quot;sl  int  CONSTRAINT C36 NOT NULL,&quot;
  + &quot;so  int  CONSTRAINT C37 NOT NULL,&quot;
  + &quot;sd  int  CONSTRAINT C38 NOT NULL,&quot;
  + &quot;sb  int  CONSTRAINT C39 NOT NULL,&quot;
  + &quot;CONSTRAINT C40 CHECK (sq &lt; 0),&quot;
  + &quot;CONSTRAINT F5 FOREIGN KEY (sid, sq) REFERENCES UQ (uid, uq),&quot;
  + &quot;CONSTRAINT F6 FOREIGN KEY (sid, se) REFERENCES UE (uid, ue),&quot;
  + &quot;CONSTRAINT F7 FOREIGN KEY (sid, sl) REFERENCES UL (uid, ul),&quot;
  + &quot;CONSTRAINT F8 FOREIGN KEY (sid, so) REFERENCES UO (uid, uo),&quot;
  + &quot;CONSTRAINT F9 FOREIGN KEY (sid, sd) REFERENCES UD (uid, ud),&quot;
  + &quot;CONSTRAINT F10 FOREIGN KEY (sid, sb) REFERENCES UB (uid, ub),&quot;
  + &quot;CONSTRAINT C41 CHECK (se &lt; sl)&quot;
  + &quot;)&quot;
</pre><p>

<pre><a name="NW1ryIo2-Uo9HJ-1" href="#NW1ryIo2-Uo9HJ-1"><dfn>&lt;Create Table R statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE R (&quot;
  + &quot;rid int  CONSTRAINT P10 PRIMARY KEY,&quot;
  + &quot;rq  int  CONSTRAINT C42 NOT NULL,&quot;
  + &quot;re  int  CONSTRAINT C43 NOT NULL,&quot;
  + &quot;rl  int  CONSTRAINT C44 NOT NULL,&quot;
  + &quot;ro  int  CONSTRAINT C45 NOT NULL,&quot;
  + &quot;rd  int  CONSTRAINT C46 NOT NULL,&quot;
  + &quot;rb  int  CONSTRAINT C47 NOT NULL,&quot;
  + &quot;CONSTRAINT C48 CHECK (rq &gt; 0),&quot;
  + &quot;CONSTRAINT F11 FOREIGN KEY (rid, rq) REFERENCES UQ (uid, uq),&quot;
  + &quot;CONSTRAINT F12 FOREIGN KEY (rid, re) REFERENCES UE (uid, ue),&quot;
  + &quot;CONSTRAINT F13 FOREIGN KEY (rid, rl) REFERENCES UL (uid, ul),&quot;
  + &quot;CONSTRAINT F14 FOREIGN KEY (rid, ro) REFERENCES UO (uid, uo),&quot;
  + &quot;CONSTRAINT F15 FOREIGN KEY (rid, rd) REFERENCES UD (uid, ud),&quot;
  + &quot;CONSTRAINT F16 FOREIGN KEY (rid, rb) REFERENCES UB (uid, ub),&quot;
  + &quot;CONSTRAINT C49 CHECK (re &lt; rl)&quot;
  + &quot;)&quot;
</pre><p>

<h3><a name=toc81>Route Endpoint Constraints Table (Table CW)</a></h3>
<a name="mod-schema: route-endpoint"><b>[*]</b></a>
<p>
Table CW stores the start and end waypoints of each server route.  The table
has nine columns, sid, se, sl, so,
sd, ts, vs, te, and ve.  The start
waypoint is stored in (sid, ts, vs) and the end
waypoint is stored in (sid, te, ve). Both of these
groups reference the (sid, t2, v2) columns in Table
W (<code>F29</code>, <code>F30</code>).  The sid column is set to be <tt>UNIQUE</tt>
(<code>C70</code>) to prevent a server from being listed multiple times and having
``multiple'' start and end waypoints.  Rule R1 is enforced by adding the
server's early and late times into columns se and sl,
referencing (sid, se) to UE (<code>F25</code>) and (sid,
sl) to UL (<code>F26</code>).  A <tt>CHECK</tt> constraint validates the start
time ts equals se (<code>C71</code>) and another one validates the end
time te is not beyond sl (<code>C72</code>).  Rule 2 is enforced by
adding the server's origin and destination into columns so and
sd, referencing (sid, so) to UO (<code>F27</code>) and
(sid, sd) to UD (<code>F28</code>).  Likewise, constraint <code>C71</code>
validates the start location vs equals so and <code>C72</code>
validates the end location ve equals sd.
<hr>
<table border><!-- alignment is |c|c|l|--><!-- 3 columns--><tr><td align="center">
Table CW (Route Endpoint Constraints)</td></tr>
<tr><td align="center">
Col. </td><td align="center">Parent </td><td align="left" valign="top">Description</td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=2 valign="middle">Table UE </td><td align="left" rowspan=2 valign="middle">Server early time \(s_\texttt{e}\)</td></tr>
<tr><td align="center">se </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=2 valign="middle">Table UL </td><td align="left" rowspan=2 valign="middle">Server late time \(s_\texttt{l}\) </td></tr>
<tr><td align="center">sl </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=2 valign="middle">Table UO </td><td align="left" rowspan=2 valign="middle">Server origin \(s_\texttt{o}\) </td></tr>
<tr><td align="center">so </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=2 valign="middle">Table UD </td><td align="left" rowspan=2 valign="middle">Server destination \(s_\texttt{d}\) </td></tr>
<tr><td align="center">sd </td></tr>
<tr><td align="center"><i><a name="NWD1ryIo2-E">sid</a></i> </td><td align="center" rowspan=3 valign="middle">Table W </td><td align="left" rowspan=3 valign="middle">Server \(\textrm{pickup}(\mathcal{X},s)\)</td></tr>
<tr><td align="center"><i>ts</i> </td></tr>
<tr><td align="center">vs </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=3 valign="middle">Table W </td><td align="left" rowspan=3 valign="middle">Server \(\textrm{dropoff}(\mathcal{X},s)\)</td></tr>
<tr><td align="center"><i>te</i> </td></tr>
<tr><td align="center">ve </td></tr>
</table>
<hr>
<p>
<pre><a name="NW1ryIo2-2HehGp-1" href="#NWD1ryIo2-E"><dfn>&lt;Create Table CW statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE CW (&quot;
  + &quot;sid int  CONSTRAINT C61 NOT NULL,&quot;
  + &quot;se  int  CONSTRAINT C62 NOT NULL,&quot;
  + &quot;sl  int  CONSTRAINT C63 NOT NULL,&quot;
  + &quot;so  int  CONSTRAINT C64 NOT NULL,&quot;
  + &quot;sd  int  CONSTRAINT C65 NOT NULL,&quot;
  + &quot;ts  int  CONSTRAINT C66 NOT NULL,&quot;
  + &quot;vs  int  CONSTRAINT C67 NOT NULL,&quot;
  + &quot;te  int  CONSTRAINT C68 NOT NULL,&quot;
  + &quot;ve  int  CONSTRAINT C69 NOT NULL,&quot;
  + &quot;CONSTRAINT C70 UNIQUE (sid),&quot;
  + &quot;CONSTRAINT P13 PRIMARY KEY (sid, ts, te),&quot;
  + &quot;CONSTRAINT F24 FOREIGN KEY (sid) REFERENCES S,&quot;
  + &quot;CONSTRAINT F25 FOREIGN KEY (sid, se) REFERENCES UE (uid, ue),&quot;
  + &quot;CONSTRAINT F26 FOREIGN KEY (sid, sl) REFERENCES UL (uid, ul),&quot;
  + &quot;CONSTRAINT F27 FOREIGN KEY (sid, so) REFERENCES UO (uid, uo),&quot;
  + &quot;CONSTRAINT F28 FOREIGN KEY (sid, sd) REFERENCES UD (uid, ud),&quot;
  + &quot;CONSTRAINT F29 FOREIGN KEY (sid, ts, vs) REFERENCES W (sid, t2, v2) INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT F30 FOREIGN KEY (sid, te, ve) REFERENCES W (sid, t2, v2) INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT C71 CHECK (ts = se),&quot;
  + &quot;CONSTRAINT C72 CHECK (vs = so),&quot;
//+ &quot;CONSTRAINT C73 CHECK (te &lt;= sl),&quot;
  + &quot;CONSTRAINT C74 CHECK (ve = sd),&quot;
  + &quot;CONSTRAINT C75 CHECK (ts &lt; te)&quot;
  + &quot;)&quot;
</pre><p>

<h3><a name=toc82>Label Constraints Table (Table CPD)</a></h3>
<a name="mod-schema: label-constraints"><b>[*]</b></a>
<p>
Table CPD enforces the pick-up and drop-off rules R5&ndash;R9. It contains twelve
columns, sid, ts, te, tp, vp,
td, vd, rid, re, rl, ro,
and rd.  The (sid, tp, vp, rid)
and (sid, td, vd, rid) groups reference
rows in Table PD (<code>F34</code>, <code>F35</code>) and represent pick-up and drop-off
waypoints, respectively.  Rules R5 and R9 are enforced by setting rid
to <tt>UNIQUE</tt> (<code>C86</code>), in other words any request identified in
rid has only one pick-up and drop-off pair.  Rule R6 is enforced by
adding columns for the request origin ro and destination rd
and validating that pick-up vertex vp equals ro (<code>C89</code>) and
drop-off vertex vd equals rd (<code>C90</code>). The (rid,
ro) columns are referenced to UO (<code>F38</code>) and (rid,
rd) are referenced to UD (<code>F39</code>).  Rules R7 and R8 are enforced by
simple <tt>CHECK</tt> constraints. Both tp and td are
validated to be between request early time re and late time
rl (<code>C89</code>, <code>C90</code>). The (rid, re) and
(rid, rl) columns are added and referenced to UE and UL
(<code>F36</code>, <code>F37</code>) for this purpose.
<p>
So far, nothing prevents tp and td from falling outside the
server's start and end times. These times are thus added into (sid,
ts, te) columns, referenced to Table CW (<code>F33</code>).  Then,
<tt>CHECK</tt> constraints can validate that tp and td are
within the start time ts and the end time te (<code>C87</code>,
<code>C88</code>).
<hr>
<table border><!-- alignment is |c|c|l|--><!-- 3 columns--><tr><td align="center">
Table CPD (Pick-up and Drop-off Constraints)</td></tr>
<tr><td align="center">
Col. </td><td align="center">Parent </td><td align="left" valign="top">Description </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=3 valign="middle">Table CW </td><td align="left" rowspan=3 valign="middle">Server start and end times \(\pi_\texttt{t}(\textrm{pickup}(\mathcal{X},s)), \pi_\texttt{t}(\textrm{dropoff}(\mathcal{X},s))\) </td></tr>
<tr><td align="center">ts </td></tr>
<tr><td align="center">te </td></tr>
<tr><td align="center"><i>sid</i> </td><td align="center" rowspan=4 valign="middle">Table PD </td><td align="left" rowspan=4 valign="middle">Request \(\textrm{pickup}(\mathcal{X},r)\) </td></tr>
<tr><td align="center"><i>tp</i> </td></tr>
<tr><td align="center">vp </td></tr>
<tr><td align="center">rid </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=4 valign="middle">Table PD </td><td align="left" rowspan=4 valign="middle">Request \(\textrm{dropoff}(\mathcal{X},r)\) </td></tr>
<tr><td align="center"><i>td</i> </td></tr>
<tr><td align="center">vd </td></tr>
<tr><td align="center"><i>rid</i> </td></tr>
<tr><td align="center">rid </td><td align="center" rowspan=2 valign="middle">Table UE </td><td align="left" rowspan=2 valign="middle">Request early time \(r_\texttt{e}\) </td></tr>
<tr><td align="center">re </td></tr>
<tr><td align="center"><a name="NWD1ryIo2-F">rid </a></td><td align="center" rowspan=2 valign="middle">Table UL </td><td align="left" rowspan=2 valign="middle">Request late time \(r_\texttt{l}\) </td></tr>
<tr><td align="center">rl </td></tr>
<tr><td align="center">rid </td><td align="center" rowspan=2 valign="middle">Table UO </td><td align="left" rowspan=2 valign="middle">Request origin \(r_\texttt{o}\) </td></tr>
<tr><td align="center">ro </td></tr>
<tr><td align="center">rid </td><td align="center" rowspan=2 valign="middle">Table UD </td><td align="left" rowspan=2 valign="middle">Request destination \(r_\texttt{d}\) </td></tr>
<tr><td align="center">rd </td></tr>
</table>
<hr>
<p>
<pre><a name="NW1ryIo2-q5ofx-1" href="#NWD1ryIo2-F"><dfn>&lt;Create Table CPD statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE CPD (&quot;
  + &quot;sid int  CONSTRAINT C76 NOT NULL,&quot;
  + &quot;ts  int  CONSTRAINT C77 NOT NULL,&quot;
  + &quot;te  int  CONSTRAINT C78 NOT NULL,&quot;
  + &quot;tp  int  CONSTRAINT C79 NOT NULL,&quot;
  + &quot;vp  int  CONSTRAINT C80 NOT NULL,&quot;
  + &quot;td  int  CONSTRAINT C81 NOT NULL,&quot;
  + &quot;vd  int  CONSTRAINT C82 NOT NULL,&quot;
  + &quot;rid int  CONSTRAINT C83 NOT NULL,&quot;
  + &quot;re  int  CONSTRAINT C84 NOT NULL,&quot;
  + &quot;rl  int  CONSTRAINT C85 NOT NULL,&quot;
  + &quot;ro  int  CONSTRAINT C86 NOT NULL,&quot;
  + &quot;rd  int  CONSTRAINT C87 NOT NULL,&quot;
  + &quot;CONSTRAINT C88 UNIQUE (rid),&quot;
  + &quot;CONSTRAINT P14 PRIMARY KEY (sid, tp, td, rid),&quot;
  + &quot;CONSTRAINT F31 FOREIGN KEY (sid) REFERENCES S,&quot;
  + &quot;CONSTRAINT F32 FOREIGN KEY (rid) REFERENCES R,&quot;
  + &quot;CONSTRAINT F33 FOREIGN KEY (sid, ts, te) REFERENCES CW (sid, ts, te) &quot;
  + &quot;  INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT F34 FOREIGN KEY (sid, tp, vp, rid) REFERENCES PD (sid, t2, v2, rid) &quot;
  + &quot;  INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT F35 FOREIGN KEY (sid, td, vd, rid) REFERENCES PD (sid, t2, v2, rid) &quot;
  + &quot;  INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT F36 FOREIGN KEY (rid, re) REFERENCES UE (uid, ue),&quot;
  + &quot;CONSTRAINT F37 FOREIGN KEY (rid, rl) REFERENCES UL (uid, ul),&quot;
  + &quot;CONSTRAINT F38 FOREIGN KEY (rid, ro) REFERENCES UO (uid, uo),&quot;
  + &quot;CONSTRAINT F39 FOREIGN KEY (rid, rd) REFERENCES UD (uid, ud),&quot;
  + &quot;CONSTRAINT C89a CHECK (tp &gt;= ts),&quot;
//  + &quot;CONSTRAINT C89b CHECK (td &lt;= te),&quot;
  + &quot;CONSTRAINT C89c CHECK (tp &lt; td),&quot;
  + &quot;CONSTRAINT C91 CHECK (tp &gt;= re),&quot;
  + &quot;CONSTRAINT C92 CHECK (vp  = ro),&quot;
//+ &quot;CONSTRAINT C93 CHECK (td &lt;= rl)&quot;,
  + &quot;CONSTRAINT C94 CHECK (vd  = rd)&quot;
  + &quot;)&quot;
</pre><p>

<!-- BUG: See Bug #1-->
<!-- Q: Why is C89B commented out?-->
<!-- A: Due to Bug #1. During service update, the route is first to be updated and-->
<!-- it's possible for vehicle end time (te) to go down. Some events might get-->
<!-- caught exceeding the new end time, so we'd like to defer C89B to give the-->
<!-- subsequent schedule update a chance to correct. The route is updated first-->
<!-- because in the usual case, the end time goes up, and if we don't do the-->
<!-- update, then new events that occur after the old end time will get caught.-->
<!--   Unfortunately when we defer C89B, we sometimes run into Bug #1. This bug-->
<!-- has appeared when using:-->
<!--   Evaluator: graphical-->
<!--   Algorithm: GreedyInsertion-->
<!--   Problem: mny-4-->
<!--   Traffic: Broadway-->
<!--   Mode: real-->
<!-- Deferring C89B is important for supporting job removal. We'll have to figure-->
<!-- out a workaround.-->

<h3><a name=toc83>Load Constraints Table (Table CQ)</a></h3>
<a name="mod-schema: load-constraints"><b>[*]</b></a>
<p>
Table CQ enforces the load rule R11. It has fourteen columns, sid,
sq, se, t1, t2, v2, q1,
q2, rid, rq, tp, td, o1,
and o2.  From Eq.&nbsp;<a href="#eq:load">[&lt;-]</a>, the load burden only changes at the
times of waypoints labeled with a request. It increases when a waypoint
corresponds to a customer pick-up and decreases when the waypoint corresponds
to a customer drop-off. Each load-changing waypoint is stored in (sid,
t2, v2, rid) and referenced to PD (<code>F46</code>).  To
determine if the waypoint is a customer pick-up or drop-off, the pick-up and
drop-off times for rid are stored in (sid, tp,
td, rid) and referenced to CPD (<code>F47</code>).  If
\(\textsf{t2}=\textsf{tp}\), then the waypoint represents a pick-up, otherwise it
represents a drop-off. The load of the server and request are stored in
(sid, sq) and (rid, rq), referenced to UQ
(<code>F44</code>, <code>F45</code>).
<p>
To validate if the load burden is always within a server's capacity, CQ must
keep track of every load change. It does so by storing the predecessor
load in columns (sid, t1, q1, o1) next to
the current load in columns (sid, t2, q2,
o2).  If the waypoint in the row is a pick-up, CQ validates that
\(\textsf{q1}+\textsf{rq}=\textsf{q2}\), otherwise that
\(\textsf{q1}-\textsf{rq}=\textsf{q2}\) (<code>C98</code>). As repetitive load changes can
occur at a single waypoint due to multiple pick-ups and drop-offs, the
o1 and o2 columns are introduced to store a unique
order number. This number increments by 1 for each pick-up or drop-off
per server and can be handled by the application. Similar rules for
establishing predecessor waypoints in Table W can be used to establish
predecessor loads in CQ.  Subsequently, (sid, t2,
q2, o2) is set to be the primary key (<code>P15</code>) in order to
allow a self-referencing foreign key on (sid, t1,
q1, o1) (<code>F42</code>), and the server early time is stored in
(sid, se) and referenced to UE (<code>F43</code>) in order to detect
the first load change.
<hr>
<table border><!-- alignment is |c|c|l|--><!-- 3 columns--><tr><td align="center">
Table CQ (Load Constraints)</td></tr>
<tr><td align="center">
Col. </td><td align="center">Parent </td><td align="left" valign="top">Description </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=2 valign="middle">Table UQ </td><td align="left" valign="middle" rowspan=2>Server load \(s_\texttt{q}\) </td></tr>
<tr><td align="center">sq </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=2 valign="middle">Table UE </td><td align="left" valign="middle" rowspan=2>Server early time \(s_\texttt{e}\) </td></tr>
<tr><td align="center">se </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=4>Table CQ </td><td align="left" valign="middle" rowspan=4>Load burden \(Q(\mathcal{X},s,\textsf{t1})\) up to order \(\textsf{o1}\) </td></tr>
<tr><td align="center">t1 </td></tr>
<tr><td align="center">q1 </td></tr>
<tr><td align="center">o1 </td></tr>
<tr><td align="center"><i>sid</i></td><td align="center" rowspan=4></td><td align="left" valign="middle" rowspan=4>Load burden \(Q(\mathcal{X},s,\textsf{t2})\) up to order \(\textsf{o2}\)</tr>
<tr><td align="center"><i>t2</i> </td></tr>
<tr><td align="center"><i>q2</i> </td></tr>
<tr><td align="center"><i>o2</i> </td></tr>
<tr><td align="center">sid </td><td align="center" rowspan=4>Table PD </td><td align="left" valign="middle" rowspan=4>Request pick-up or delivery waypoint </td></tr>
<tr><td align="center">t2 </td></tr>
<tr><td align="center">v2 </td></tr>
<tr><td align="center">rid</td></tr>
<tr><td align="center"><a name="NWD1ryIo2-G">sid </a></td><td align="center" rowspan=4>Table CPD </td><td align="left" valign="middle" rowspan=4>Request pick-up and delivery times \(\pi_\texttt{t}(\textrm{pickup}(\mathcal{X},r)), \pi_\texttt{t}(\textrm{dropoff}(\mathcal{X},r))\) </td></tr>
<tr><td align="center">tp </td></tr>
<tr><td align="center">td </td></tr>
<tr><td align="center">rid</td></tr>
<tr><td align="center">rid </td><td align="center" rowspan=2 valign="middle">Table UQ </td><td align="left" valign="middle" rowspan=2>Request load \(r_\texttt{q}\) </td></tr>
<tr><td align="center">rq </td></tr>
</table>
<hr>
<p>
<pre><a name="NW1ryIo2-2YsMAX-1" href="#NWD1ryIo2-G"><dfn>&lt;Create Table CQ statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE TABLE CQ (&quot;
  + &quot;sid int  CONSTRAINT C95 NOT NULL,&quot;
  + &quot;sq  int  CONSTRAINT C96 NOT NULL,&quot;
  + &quot;se  int  CONSTRAINT C97 NOT NULL,&quot;
  + &quot;t1  int  ,&quot;
  + &quot;t2  int  CONSTRAINT C98 NOT NULL,&quot;
  + &quot;v2  int  ,&quot;
  + &quot;q1  int  ,&quot;
  + &quot;q2  int  CONSTRAINT C99 NOT NULL,&quot;
  + &quot;rid int  ,&quot;
  + &quot;rq  int  ,&quot;
  + &quot;tp  int  ,&quot;
  + &quot;td  int  ,&quot;
  + &quot;o1  int  ,&quot;
  + &quot;o2  int  CONSTRAINT C100 NOT NULL,&quot;
  + &quot;CONSTRAINT C101 CHECK (o2 &gt; 0),&quot;
  + &quot;CONSTRAINT P15 PRIMARY KEY (sid, t2, q2, o2),&quot;
  + &quot;CONSTRAINT F40 FOREIGN KEY (sid) REFERENCES S,&quot;
  + &quot;CONSTRAINT F41 FOREIGN KEY (rid) REFERENCES R,&quot;
  + &quot;CONSTRAINT F42 FOREIGN KEY (sid, t1, q1, o1) REFERENCES CQ (sid, t2, q2, o2)&quot;
  + &quot;  INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT F43 FOREIGN KEY (sid, se) REFERENCES UE (uid, ue),&quot;
  + &quot;CONSTRAINT F44 FOREIGN KEY (sid, sq) REFERENCES UQ (uid, uq),&quot;
  + &quot;CONSTRAINT F45 FOREIGN KEY (rid, rq) REFERENCES UQ (uid, uq),&quot;
  + &quot;CONSTRAINT F46 FOREIGN KEY (sid, t2, v2, rid) REFERENCES PD INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT F47 FOREIGN KEY (sid, tp, td, rid) REFERENCES CPD INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT C102a CHECK (CASE WHEN t1 IS NULL THEN t2 = se END),&quot;
  + &quot;CONSTRAINT C102b CHECK (CASE WHEN t1 IS NULL THEN q2 = sq END),&quot;
  + &quot;CONSTRAINT C102c CHECK (CASE WHEN t1 IS NULL THEN o2 = 1 END),&quot;
  + &quot;CONSTRAINT C102d CHECK (CASE WHEN t1 IS NULL THEN q1 IS NULL END),&quot;
  + &quot;CONSTRAINT C102e CHECK (CASE WHEN t1 IS NULL THEN o1 IS NULL END),&quot;
  + &quot;CONSTRAINT C102f CHECK (CASE WHEN t1 IS NULL THEN rid IS NULL END),&quot;
  + &quot;CONSTRAINT C102g CHECK (CASE WHEN t1 IS NULL THEN rq IS NULL END),&quot;
  + &quot;CONSTRAINT C102h CHECK (CASE WHEN t1 IS NULL THEN tp IS NULL END),&quot;
  + &quot;CONSTRAINT C102i CHECK (CASE WHEN t1 IS NULL THEN td IS NULL END),&quot;
  + &quot;CONSTRAINT C102j CHECK (CASE WHEN t1 IS NOT NULL THEN q2 &lt;= 0 END),&quot;
  + &quot;CONSTRAINT C102k CHECK (CASE WHEN t1 IS NOT NULL THEN o2 = o1 + 1 END),&quot;
  + &quot;CONSTRAINT C103 CHECK (CASE WHEN t2 = tp THEN q2 = q1 + rq END) INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT C104 CHECK (CASE WHEN t2 = td THEN q2 = q1 - rq END) INITIALLY DEFERRED,&quot;
  + &quot;CONSTRAINT C105 UNIQUE (t2, v2, rid)&quot;
  + &quot;)&quot;
</pre><p>

<h3><a name=toc84><a name="NWD1ryIo2-H">Views</a></a></h3>
<a name="mod-schema: views"><b>[*]</b></a>
<p>
The user relation \(\mathcal{U}\) can be formed by a union of Table S and R.
<p><pre><a name="NW1ryIo2-3mP67S-1" href="#NWD1ryIo2-H"><dfn>&lt;Create View r_user statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW r_user (uid, uq, ue, ul, uo, ud, ub) AS &quot;
  + &quot;SELECT * from S UNION SELECT * from R&quot;
</pre><p>

<a name="NWD1ryIo2-I">The server relation </a>\(\mathcal{X}\) can be constructed by joining the routes in
Table W with the labels in CW and PD.
<p><pre><a name="NW1ryIo2-4cerAN-1" href="#NWD1ryIo2-I"><dfn>&lt;Create View r_server statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW r_server (sid, t, v, Ls, Lr) AS &quot;
  + &quot;SELECT W.sid, W.t2, W.v2, CW.sid, PD.rid &quot;
  + &quot;FROM W LEFT OUTER JOIN CW ON W.sid = CW.sid AND (W.t2 = CW.ts OR W.t2 = CW.te) &quot;
  + &quot;  LEFT OUTER JOIN PD ON W.sid = PD.sid AND W.t2 = PD.t2&quot;
</pre><p>

<a name="NWD1ryIo2-J">The cruising and service distances </a>\(D^\textrm{cruise}\) and \(D^\textrm{service}\)
require an auxilliary view. This view joins Table W with
CQ in such a way that the distances in column \(\textsf{dd}\) of W
can be aggregated based on whether there is load burden at the time of the
waypoint.
<p><pre><a name="NW1ryIo2-3AQnVd-1" href="#NWD1ryIo2-J"><dfn>&lt;Create View f_distance_blocks statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW f_distance_blocks (sid, wt1, wt2, wdd, cqsq, cqt1, cqt2, cqq1, cqq2) &quot;
  + &quot;AS SELECT W.sid, W.t1, W.t2, W.dd, CQ.sq, CQ.t1, CQ.t2, CQ.q1, CQ.q2 &quot;
  + &quot;FROM W LEFT OUTER JOIN CQ ON W.sid = CQ.sid and W.t2 &gt; CQ.t1 and W.t2 &lt;= CQ.t2 &quot;
  + &quot;WHERE W.dd IS NOT NULL&quot;
</pre><p>

<a name="NWD1ryIo2-K">Request status can also be obtained using an auxilliary view.  This view lists</a>
the count of occurrences of a request in column \(\textsf{rid}\) of CQ,
corresponding to the request status.  Table CQ is used to get the counts over
time.  If the count is 0, it will not appear in the aggregation and the status
for the request is ``waiting''.
<p><pre><a name="NW1ryIo2-2gB9c6-1" href="#NWD1ryIo2-K"><dfn>&lt;Create View f_status statement (Eq.&nbsp;<a href="#eq:status">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW f_status (t, sid, rid, val) AS &quot;
  + &quot;SELECT a.t2, a.sid, a.rid, COUNT (b.rid) &quot;
  + &quot;FROM CQ AS a INNER JOIN CQ AS b ON a.t2 &gt;= b.t2 &quot;
  + &quot;WHERE a.rid IS NOT NULL AND b.rid IS NOT NULL AND a.rid = b.rid &quot;
  + &quot;GROUP BY a.t2, a.sid, a.rid&quot;
</pre><p>

<a name="NWD1ryIo2-L">To list all assignments </a>\(\mathcal{A}\):
<p><pre><a name="NW1ryIo2-2P9ed9-1" href="#NWD1ryIo2-L"><dfn>&lt;Create View assignments statement (Eq.&nbsp;<a href="#eq:assignments">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW assignments (t, sid, rid) AS &quot;
  + &quot;SELECT t, sid, rid FROM f_status WHERE val = 2 ORDER BY t ASC&quot;
</pre><p>
<a name="NWD1ryIo2-M">To list assigned requests </a>\(\mathcal{R}^\textrm{ok}\):
<p><pre><a name="NW1ryIo2-3URYrA-1" href="#NWD1ryIo2-M"><dfn>&lt;Create View assignments_r statement (Eq.&nbsp;<a href="#eq:assigned-requests">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW assignments_r (t, rid) AS &quot;
  + &quot;SELECT t, rid FROM assignments&quot;
</pre><p>
<a name="NWD1ryIo2-N">To list service rate </a>\(\mu\):
<p><pre><a name="NW1ryIo2-2DZxd4-1" href="#NWD1ryIo2-N"><dfn>&lt;Create View service_rate statement (Eq.&nbsp;<a href="#eq:service-rate">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW service_rate (val) AS &quot;
  + &quot;SELECT CAST(CAST(A.NUM AS FLOAT) / CAST(A.DENOM AS FLOAT) * 10000 as INT)&quot;
  + &quot;FROM ( &quot;
  + &quot;SELECT (SELECT COUNT(*) FROM assignments_r) AS NUM, &quot;
  + &quot;       (SELECT COUNT(*) FROM R) AS DENOM &quot;
  + &quot;       FROM R FETCH FIRST ROW ONLY &quot;
  + &quot;) A&quot;
</pre><p>
<a name="NWD1ryIo2-O">To list base distance </a>\(D^\textrm{base}\):
<p><pre><a name="NW1ryIo2-qlTK4-1" href="#NWD1ryIo2-O"><dfn>&lt;Create View dist_base statement (Eq.&nbsp;<a href="#eq:base-distance">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dist_base (val) AS &quot;
  + &quot;SELECT SUM (ub) FROM UB&quot;
</pre><p>
<a name="NWD1ryIo2-P">To list travel distances </a>\(D\) of all servers:
<p><pre><a name="NW1ryIo2-4eo46z-1" href="#NWD1ryIo2-P"><dfn>&lt;Create View dist_s_travel statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dist_s_travel (sid, val) AS &quot;
  + &quot;SELECT W.sid, SUM (COALESCE (dd, 0)) &quot;
  + &quot;FROM W JOIN CW ON w.sid = cw.sid AND (t2 BETWEEN ts AND te) &quot;
  + &quot;GROUP BY W.sid&quot;
</pre><p>
<a name="NWD1ryIo2-Q">To list cruising distances </a>\(D^\textrm{cruise}\) of all servers:
<p><pre><a name="NW1ryIo2-2qMSvI-1" href="#NWD1ryIo2-Q"><dfn>&lt;Create View dist_s_cruising statement (Eq.&nbsp;<a href="#eq:cruising-distance">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dist_s_cruising (sid, val) AS &quot;
  + &quot;SELECT sid, SUM (wdd) FROM f_distance_blocks &quot;
  + &quot;WHERE cqq1 = cqsq OR cqq1 IS NULL GROUP BY sid&quot;
</pre><p>
<a name="NWD1ryIo2-R">To list service distances </a>\(D^\textrm{service}\) of all servers:
<p><pre><a name="NW1ryIo2-3uXzrW-1" href="#NWD1ryIo2-R"><dfn>&lt;Create View dist_s_service statement (Eq.&nbsp;<a href="#eq:service-distance">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dist_s_service (sid, val) AS &quot;
  + &quot;SELECT sid, SUM (wdd) FROM f_distance_blocks &quot;
  + &quot;WHERE cqq1 &gt; cqsq GROUP BY sid&quot;
</pre><p>
<a name="NWD1ryIo2-S">To list base distances </a>\(d\) of all servers:
<p><pre><a name="NW1ryIo2-1SKOKb-1" href="#NWD1ryIo2-S"><dfn>&lt;Create View dist_s_base statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dist_s_base (val) AS &quot;
  + &quot;SELECT SUM (sb) FROM S&quot;
</pre><p>
<a name="NWD1ryIo2-T">To list base distances </a>\(d\) of all requests:
<p><pre><a name="NW1ryIo2-1kGrze-1" href="#NWD1ryIo2-T"><dfn>&lt;Create View dist_r_base statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dist_r_base (val) AS &quot;
  + &quot;SELECT SUM (rb) FROM R&quot;
</pre><p>
<a name="NWD1ryIo2-U">To list base distances </a>\(d\) of all unassigned requests:
<p><pre><a name="NW1ryIo2-29pkrK-1" href="#NWD1ryIo2-U"><dfn>&lt;Create View dist_r_unassigned statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dist_r_unassigned (val) AS &quot;
  + &quot;SELECT SUM (rb) FROM R LEFT JOIN assignments_r &quot;
  + &quot;  ON R.rid = assignments_r.rid &quot;
  + &quot;WHERE assignments_r.rid IS NULL&quot;
</pre><p>
<a name="NWD1ryIo2-V">To list detour distances </a>\(D^\textrm{detour}\) of all requests:
<p><pre><a name="NW1ryIo2-3GYStw-1" href="#NWD1ryIo2-V"><dfn>&lt;Create View dist_r_detour statement (Eq.&nbsp;<a href="#eq:detour-distance">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dist_r_detour (rid, val) AS &quot;
  + &quot;SELECT rid, val-ub FROM UB JOIN dist_r_transit ON uid = rid&quot;
</pre><p>
<a name="NWD1ryIo2-W">To list transit distances </a>\(D^\textrm{transit}\) of all requests:
<p><pre><a name="NW1ryIo2-3Hjm-1" href="#NWD1ryIo2-W"><dfn>&lt;Create View dist_r_transit statement (Eq.&nbsp;<a href="#eq:transit-distance">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dist_r_transit (rid, val) AS &quot;
  + &quot;SELECT rid, SUM (COALESCE (dd, 0)) &quot;
  + &quot;FROM CPD JOIN W ON CPD.sid = W.sid AND CPD.tp &lt; W.t2 AND W.t2 &lt;= CPD.td &quot;
  + &quot;GROUP BY rid&quot;
</pre><p>
<a name="NWD1ryIo2-X">To list travel duration </a>\(\delta\) of all servers:
<p><pre><a name="NW1ryIo2-3HstiH-1" href="#NWD1ryIo2-X"><dfn>&lt;Create View dur_s_travel statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dur_s_travel (sid, val) AS &quot;
  + &quot;SELECT sid, te - ts FROM CW&quot;
</pre><p>
<a name="NWD1ryIo2-Y">To list service duration of all servers:</a>
<p><pre><a name="NW1ryIo2-SkJCA-1" href="#NWD1ryIo2-Y"><dfn>&lt;Create View dur_s_service statement&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dur_s_service (sid, val) AS &quot;
  + &quot;SELECT sid, sum (t2 - t1) FROM CQ WHERE Q1 &lt;&gt; SQ GROUP BY sid&quot;
</pre><p>
<a name="NWD1ryIo2-Z">To list pick-up delay </a>\(\delta^\textrm{pickup}\) of all requests:
<p><pre><a name="NW1ryIo2-3svzZz-1" href="#NWD1ryIo2-Z"><dfn>&lt;Create View dur_r_pickup statement (Eq.&nbsp;<a href="#eq:pick-up delay">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dur_r_pickup (rid, val) AS &quot;
  + &quot;SELECT rid, tp - re FROM CPD&quot;
</pre><p>
<a name="NWD1ryIo2-a">To list transit durations </a>\(\delta^\textrm{transit}\) of all requests:
<p><pre><a name="NW1ryIo2-4fGRrm-1" href="#NWD1ryIo2-a"><dfn>&lt;Create View dur_r_transit statement (Eq.&nbsp;<a href="#eq:transit-duration">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dur_r_transit (rid, val) AS &quot;
  + &quot;SELECT rid, td - tp FROM CPD&quot;
</pre><p>
<a name="NWD1ryIo2-b">To list travel durations </a>\(\delta^\textrm{travel}\) of all requests:
<p><pre><a name="NW1ryIo2-48GDve-1" href="#NWD1ryIo2-b"><dfn>&lt;Create View dur_r_travel statement (Eq.&nbsp;<a href="#eq:travel-duration">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW dur_r_travel (rid, val) AS &quot;
  + &quot;SELECT rid, td - re FROM CPD&quot;
</pre><p>
<a name="NWD1ryIo2-c">To list departure times </a>\(t^\textrm{depart}\) of all requests:
<p><pre><a name="NW1ryIo2-2zvpe9-1" href="#NWD1ryIo2-c"><dfn>&lt;Create View t_r_depart statement (Eq.&nbsp;<a href="#eq:departure-time">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW t_r_depart (rid, val) AS &quot;
  + &quot;SELECT rid, tp FROM CPD&quot;
</pre><p>
<a name="NWD1ryIo2-d">To list departure times </a>\(t^\textrm{depart}\) of all servers:
<p><pre><a name="NW1ryIo2-4TfcEP-1" href="#NWD1ryIo2-d"><dfn>&lt;Create View t_s_depart statement (Eq.&nbsp;<a href="#eq:departure-time">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW t_s_depart (sid, val) AS &quot;
  + &quot;SELECT sid, ts FROM CW&quot;
</pre><p>
<a name="NWD1ryIo2-e">To list arrival times </a>\(t^\textrm{arrive}\) of all requests:
<p><pre><a name="NW1ryIo2-15u9Xt-1" href="#NWD1ryIo2-e"><dfn>&lt;Create View t_r_arrive statement (Eq.&nbsp;<a href="#eq:arrival-time">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW t_r_arrive (rid, val) AS &quot;
  + &quot;SELECT rid, td FROM CPD&quot;
</pre><p>
<a name="NWD1ryIo2-f">To list arrival times </a>\(t^\textrm{arrive}\) of all servers:
<p><pre><a name="NW1ryIo2-4DqTeE-1" href="#NWD1ryIo2-f"><dfn>&lt;Create View t_s_arrive statement (Eq.&nbsp;<a href="#eq:arrival-time">[&lt;-]</a>)&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW t_s_arrive (sid, val) AS &quot;
  + &quot;SELECT sid, te FROM CW&quot;
</pre><p>
<a name="NWD1ryIo2-g">To list time window violations of all servers:</a>
<p><pre><a name="NW1ryIo2-3BIsIJ-1" href="#NWD1ryIo2-g"><dfn>&lt;Create View violations_t_s&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW violations_t_s (sid, val) AS &quot;
  + &quot;SELECT sid, te - sl FROM CW WHERE te - sl &gt; 0&quot;
</pre><p>
<a name="NWD1ryIo2-h">To list time window violations of all requests:</a>
<p><pre><a name="NW1ryIo2-1cnG4N-1" href="#NWD1ryIo2-h"><dfn>&lt;Create View violations_t_r&gt;=</dfn></a> <b>(<a href="#NWD1ODIS0-s">U-&gt;</a>)</b>
&quot;CREATE VIEW violations_t_r (rid, val) AS &quot;
  + &quot;SELECT rid, td - rl FROM CPD WHERE td - rl &gt; 0&quot;
</pre><p>

</body>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</html>

